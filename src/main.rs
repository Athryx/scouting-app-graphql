#![feature(duration_consts_2)]

// the schema file generated by diesel requires this
#[macro_use]
extern crate diesel;
#[macro_use]
extern crate diesel_derive_enum;
#[macro_use]
extern crate rocket;
#[macro_use]
extern crate juniper;

mod api;
mod db;
mod prelude;
mod token;
mod context;

use rocket::{State, response::{Redirect, content::Html}};
use juniper::{RootNode, EmptySubscription};
use juniper_rocket::{GraphQLRequest, GraphQLResponse, graphiql_source, playground_source};
use diesel::r2d2::Error;
use dotenv::dotenv;

use db::Connection;
pub use token::{UserToken, UserTokenGuard};
pub use context::Context;
use api::{ApiRoot, query::RootQuery, mutation::RootMutation};

#[get("/graphql?<request>")]
fn get_graphql(request: GraphQLRequest, api_root: &State<ApiRoot>, db_conn: &State<Connection>, token: UserTokenGuard) -> GraphQLResponse {
	let context = Context::new(db_conn.get().unwrap(), token);
	request.execute_sync(api_root, &context)
}

#[post("/graphql", data = "<request>")]
fn post_graphql(request: GraphQLRequest, api_root: &State<ApiRoot>, db_conn: &State<Connection>, token: UserTokenGuard) -> GraphQLResponse{
	let context = Context::new(db_conn.get().unwrap(), token);
	request.execute_sync(api_root, &context)
}

// TODO: decide on either graphiql or graphql playground, and remove the other
#[get("/graphiql")]
fn graphiql() -> Html<String> {
	graphiql_source("/graphql", None)
}

#[get("/graphql_playground")]
fn graphql_playground() -> Html<String> {
	playground_source("/graphql", None)
}

#[get("/")]
fn index() -> Redirect {
	Redirect::to("/graphql_playground")
}

#[launch]
fn rocket() -> _ {
	// load enviroment variables into process
	// ignore failure
	dotenv().ok();

	rocket::build()
		.manage(Connection::from_env())
		.manage(RootNode::new(RootQuery, RootMutation, EmptySubscription::<Context>::new()))
		.mount("/", routes![index, get_graphql, post_graphql, graphiql, graphql_playground])
}
